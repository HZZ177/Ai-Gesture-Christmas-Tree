<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas Tree By kk</title>
    <style>
        /* ä¿®æ”¹èƒŒæ™¯ä¸ºæµ…è‰²æ¸å˜ï¼ŒåŒ¹é… config.html */
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            font-family: 'Times New Roman', serif;
            touch-action: none; /* ç¦æ­¢æµè§ˆå™¨é»˜è®¤çš„ç¼©æ”¾å’Œå¹³ç§» */
            user-select: none;  /* ç¦æ­¢é€‰ä¸­æ–‡å­— */
            -webkit-user-select: none;
            position: relative;
        }

        /* é›ªèŠ±èƒŒæ™¯åŠ¨ç”» - åŒ¹é… config.html */
        .snowflake {
            position: fixed;
            top: -10px;
            color: white;
            font-size: 1em;
            font-family: Arial, sans-serif;
            text-shadow: 0 0 5px #fff;
            animation: fall linear infinite;
            opacity: 0.8;
            pointer-events: none;
            z-index: 2;
        }

        @keyframes fall {
            0% {
                top: -10%;
                opacity: 0.8;
            }
            100% {
                top: 110%;
                opacity: 0.2;
            }
        }

        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; cursor: grab; }
        #canvas-container:active { cursor: grabbing; }

        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; 
            align-items: center;
            padding-top: 40px;
            box-sizing: border-box;
            transition: opacity 0.5s ease;
        }
        
        .ui-hidden { opacity: 0 !important; pointer-events: none !important; }

        /* Loading */
        /* å…¨å±åœ£è¯ä¸»é¢˜åŠ è½½é¡µ */
        #loader {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at top, #264d73 0%, #050d1a 55%, #02040a 100%);
            overflow: hidden;
            transition: opacity 0.8s ease-out;
        }

        .loader-scene {
            position: relative;
            width: min(320px, 70vw);
            height: min(320px, 70vw);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .loader-moon {
            position: absolute;
            top: 10%;
            right: 15%;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #fffbe6 0%, #ffd666 35%, #b38f00 80%);
            box-shadow: 0 0 25px rgba(255, 214, 102, 0.7);
            opacity: 0.9;
        }

        .loader-tree {
            position: relative;
            width: 60%;
            height: 80%;
            display: flex;
            align-items: center;
            justify-content: center;
            filter: drop-shadow(0 10px 25px rgba(0, 0, 0, 0.8));
        }

        .tree-layer {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-style: solid;
            border-left-color: transparent;
            border-right-color: transparent;
            border-bottom-style: solid;
            border-bottom-color: #0f4d31;
            opacity: 0.95;
            animation: treeFloat 3s ease-in-out infinite;
        }

        .tree-layer.layer-1 {
            bottom: 32%;
            border-width: 0 min(80px, 26vw) min(95px, 30vw) min(80px, 26vw);
            animation-delay: 0s;
        }

        .tree-layer.layer-2 {
            bottom: 46%;
            border-width: 0 min(65px, 22vw) min(80px, 26vw) min(65px, 22vw);
            animation-delay: 0.25s;
        }

        .tree-layer.layer-3 {
            bottom: 60%;
            border-width: 0 min(50px, 18vw) min(65px, 22vw) min(50px, 18vw);
            animation-delay: 0.5s;
        }

        .tree-trunk {
            position: absolute;
            bottom: 24%;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 40px;
            background: linear-gradient(to bottom, #5c3d1e, #2b1b0d);
            border-radius: 4px;
        }

        .tree-star {
            position: absolute;
            bottom: 70%;
            left: 50%;
            transform: translateX(-50%) rotate(0deg);
            width: 0;
            height: 0;
            margin-left: -12px;
            border-right: 12px solid transparent;
            border-bottom: 24px solid #ffd700;
            border-left: 12px solid transparent;
            transform-origin: 50% 80%;
            animation: starTwinkle 1.8s ease-in-out infinite;
        }

        .tree-star::before,
        .tree-star::after {
            content: '';
            position: absolute;
            top: 7px;
            left: -12px;
            width: 0;
            height: 0;
            border-right: 12px solid transparent;
            border-bottom: 24px solid #ffd700;
            border-left: 12px solid transparent;
            transform-origin: 50% 80%;
        }

        .tree-star::before {
            transform: rotate(72deg);
        }

        .tree-star::after {
            transform: rotate(-72deg);
        }

        .tree-ornament {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #fff, #ff4d4f);
            box-shadow: 0 0 12px rgba(255, 77, 79, 0.7);
            animation: ornamentGlow 1.6s ease-in-out infinite;
        }

        .tree-ornament.gold {
            background: radial-gradient(circle at 30% 30%, #fffbe6, #ffd666);
            box-shadow: 0 0 14px rgba(255, 214, 102, 0.8);
        }

        .tree-ornament.green {
            background: radial-gradient(circle at 30% 30%, #e6fffb, #36cfc9);
            box-shadow: 0 0 10px rgba(54, 207, 201, 0.8);
        }

        .tree-ornament.o1 { bottom: 36%; left: 42%; animation-delay: 0s; }
        .tree-ornament.o2 { bottom: 40%; right: 36%; animation-delay: 0.3s; }
        .tree-ornament.o3 { bottom: 52%; left: 48%; animation-delay: 0.6s; }
        .tree-ornament.o4 { bottom: 56%; right: 40%; animation-delay: 0.9s; }
        .tree-ornament.o5 { bottom: 66%; left: 44%; animation-delay: 1.2s; }

        .loader-garland {
            position: absolute;
            bottom: 40%;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
            height: 40%;
            border-radius: 50%;
            border: 2px dashed rgba(255, 255, 255, 0.35);
            border-top-color: transparent;
            border-left-color: transparent;
            border-right-color: transparent;
            animation: garlandWave 2.4s ease-in-out infinite;
        }

        .loader-present {
            position: absolute;
            bottom: 20%;
            right: 18%;
            width: 40px;
            height: 32px;
            background: linear-gradient(135deg, #c41e3a, #8c1d2f);
            border-radius: 4px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.5);
            animation: presentBounce 1.8s ease-in-out infinite;
        }

        .loader-present::before,
        .loader-present::after {
            content: '';
            position: absolute;
            background: #ffd700;
        }

        .loader-present::before {
            inset: 0 16px;
        }

        .loader-present::after {
            inset: -8px 0 auto 0;
            height: 10px;
            border-radius: 4px 4px 0 0;
        }

        .loader-present-ribbon {
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 18px;
            height: 10px;
            border-radius: 50% 50% 0 0;
            border: 2px solid #ffd700;
            border-bottom: none;
        }

        .loader-text {
            margin-top: 24px;
            text-align: center;
            color: #fdfcf5;
        }

        .loader-title {
            font-family: 'Cinzel', 'Times New Roman', serif;
            font-size: 20px;
            letter-spacing: 4px;
            text-transform: uppercase;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
        }

        .loader-subtitle {
            font-size: 14px;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.85);
        }

        .loader-subtitle span {
            color: #ffd666;
            font-weight: 600;
        }

        @keyframes treeFloat {
            0%, 100% { transform: translate(-50%, 0); }
            50% { transform: translate(-50%, -6px); }
        }

        @keyframes starTwinkle {
            0%, 100% { transform: translateX(-50%) scale(1); filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8)); }
            50% { transform: translateX(-50%) scale(1.1); filter: drop-shadow(0 0 16px rgba(255, 255, 255, 1)); }
        }

        @keyframes ornamentGlow {
            0%, 100% { transform: translateY(0); opacity: 0.8; }
            50% { transform: translateY(-3px); opacity: 1; }
        }

        @keyframes garlandWave {
            0%, 100% { transform: translateX(-50%) rotate(2deg); opacity: 0.55; }
            50% { transform: translateX(-50%) rotate(-2deg); opacity: 0.8; }
        }

        @keyframes presentBounce {
            0%, 100% { transform: translateY(0); }
            20% { transform: translateY(-6px); }
            40% { transform: translateY(0); }
            60% { transform: translateY(-3px); }
            80% { transform: translateY(0); }
        }

        /* Typography */
        h1 { 
            color: #fceea7; font-size: 8vw; 
            max-size: 56px; margin: 0; font-weight: 400; 
            letter-spacing: 6px; 
            text-shadow: 0 0 50px rgba(252, 238, 167, 0.6); 
            background: linear-gradient(to bottom, #fff, #eebb66);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            font-family: 'Cinzel', 'Times New Roman', serif;
            opacity: 0.9; transition: opacity 0.5s ease;
            text-align: center; pointer-events: none;
        }
        @media (min-width: 768px) { h1 { font-size: 56px; } }

        /* Controls */
        .controls-wrapper {
            position: absolute; top: 100px; right: 20px;        
            pointer-events: auto;
            display: flex; flex-direction: column; align-items: flex-end;
            gap: 10px; z-index: 20;
            transition: opacity 0.5s ease;
        }

        .btn-group {
            display: flex; flex-direction: column; gap: 10px; align-items: flex-end;
        }

        .control-btn {
            background: rgba(20, 20, 20, 0.6); 
            border: 1px solid rgba(212, 175, 55, 0.4); 
            color: #d4af37; padding: 10px 20px; 
            cursor: pointer; text-transform: uppercase; 
            letter-spacing: 2px; font-size: 10px;
            transition: all 0.4s;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px); min-width: 120px;
        }
        
        .control-btn.active {
            background: rgba(212, 175, 55, 0.8); color: #000;
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.6);
        }
        .control-btn:hover { 
            background: #d4af37; color: #000; 
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }
        
        .hint-text {
            color: rgba(212, 175, 55, 0.5); font-size: 9px;
            letter-spacing: 1px; text-transform: uppercase;
            text-align: right; margin-top: 5px; max-width: 200px;
        }

        input[type="file"] { display: none; }

        /* Mode Buttons (Right Bottom) - 1åˆ—å¤šè¡Œå¸ƒå±€ */
        #mode-bar {
            position: fixed;
            bottom: 30px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 20;
            pointer-events: auto;
        }
        .mode-btn {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(160, 80, 90, 0.7) 0%, rgba(60, 100, 80, 0.7) 100%);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(200, 180, 120, 0.6);
            color: #f0f0f0;
            font-size: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(100, 60, 70, 0.3);
        }
        .mode-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(100, 60, 70, 0.5);
            border-color: rgba(200, 180, 120, 0.9);
        }
        .mode-btn:active {
            transform: scale(0.95);
            background: linear-gradient(135deg, rgba(80, 120, 100, 0.85) 0%, rgba(60, 100, 80, 0.85) 100%);
        }
        
        /* Webcam feedback */
        #webcam-wrapper {
            position: fixed; bottom: 100px; left: 20px;
            width: 120px; height: 90px;
            border: 1px solid rgba(212, 175, 55, 0.5);
            box-shadow: 0 0 20px rgba(0,0,0,0.9);
            border-radius: 4px; overflow: hidden;
            opacity: 0; pointer-events: none;
            z-index: 150; background: #000;
            transition: opacity 0.5s ease;
        }
        #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        #debug-info {
            display: none; /* éšè—è°ƒè¯•ä¿¡æ¯ */
        }

        /* Toast é€šçŸ¥å®¹å™¨ */
        #toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            background: linear-gradient(135deg, rgba(160, 80, 90, 0.9) 0%, rgba(60, 100, 80, 0.9) 100%);
            border: 2px solid rgba(200, 180, 120, 0.7);
            border-radius: 12px;
            padding: 14px 20px;
            color: #f0f0f0;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 8px 25px rgba(100, 60, 70, 0.4), 0 0 20px rgba(150, 130, 100, 0.3);
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 280px;
            max-width: 400px;
            opacity: 0;
            transform: translateX(120%);
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        .toast.success {
            background: linear-gradient(135deg, rgba(60, 100, 80, 0.9) 0%, rgba(80, 120, 100, 0.9) 100%);
        }

        .toast.error {
            background: linear-gradient(135deg, rgba(160, 80, 90, 0.9) 0%, rgba(180, 90, 100, 0.9) 100%);
        }

        .toast.warning {
            background: linear-gradient(135deg, rgba(180, 140, 80, 0.9) 0%, rgba(160, 120, 70, 0.9) 100%);
        }

        .toast-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .toast-text {
            flex: 1;
            line-height: 1.4;
        }

        /* åœ£è¯ä¸»é¢˜åŠ è½½æç¤º - ä½é¥±å’Œåº¦é…è‰² */
        #loading-toast {
            position: fixed;
            bottom: 60px;
            right: 20px;
            background: linear-gradient(135deg, rgba(160, 80, 90, 0.85) 0%, rgba(60, 100, 80, 0.85) 100%);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(200, 180, 120, 0.6);
            border-radius: 16px;
            padding: 14px 22px;
            color: #f0f0f0;
            font-size: 11px;
            letter-spacing: 1px;
            z-index: 150;
            display: flex;
            align-items: center;
            gap: 12px;
            opacity: 0;
            transform: translateX(120%);
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            pointer-events: none;
            box-shadow: 0 8px 25px rgba(100, 60, 70, 0.3), 0 0 20px rgba(150, 130, 100, 0.2);
            position: relative;
            overflow: hidden;
        }

        #loading-toast::before {
            content: 'ğŸ„';
            position: absolute;
            left: -5px;
            top: -5px;
            font-size: 20px;
            opacity: 0.3;
            animation: snowfall 3s infinite;
        }

        #loading-toast::after {
            content: 'â„ï¸';
            position: absolute;
            right: -5px;
            bottom: -5px;
            font-size: 16px;
            opacity: 0.3;
            animation: snowfall 3s 1.5s infinite;
        }

        @keyframes snowfall {
            0%, 100% { transform: translateY(0) rotate(0deg); opacity: 0.3; }
            50% { transform: translateY(5px) rotate(180deg); opacity: 0.6; }
        }

        #loading-toast.show {
            opacity: 1;
            transform: translateX(0);
        }

        .toast-spinner {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-top-color: rgba(200, 180, 120, 0.8);
            border-right-color: rgba(200, 180, 120, 0.8);
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        .toast-text {
            font-weight: 500;
            text-transform: uppercase;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* éšç§è¯´æ˜ - åœ£è¯ä¸»é¢˜ */
        #privacy-notice {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 8px 20px;
            
            color: rgba(255, 215, 0, 0.8);
            font-size: 8px;
            text-align: center;
            letter-spacing: 0.5px;
            z-index: 50;
            font-weight: 300;
        }

        /* ä½¿ç”¨è¯´æ˜æŒ‰é’® */
        #help-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #c41e3a 0%, #165b33 100%);
            border: 2px solid #ffd700;
            color: #ffd700;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            pointer-events: auto;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(196, 30, 58, 0.4), 0 0 20px rgba(255, 215, 0, 0.2);
            animation: pulse 2s ease-in-out infinite;
        }

        #help-btn:hover {
            transform: scale(1.1) rotate(10deg);
            box-shadow: 0 6px 25px rgba(196, 30, 58, 0.6), 0 0 30px rgba(255, 215, 0, 0.4);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .help-tooltip {
            position: absolute;
            top: 50%;
            right: 60px;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #c41e3a 0%, #165b33 100%);
            color: #fff;
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 11px;
            white-space: nowrap;
            border: 1px solid #ffd700;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            letter-spacing: 0.5px;
            animation: float 2s ease-in-out infinite;
        }

        .help-tooltip::after {
            content: '';
            position: absolute;
            right: -8px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid #165b33;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
        }

        @keyframes float {
            0%, 100% { transform: translateY(-50%); }
            50% { transform: translateY(-55%); }
        }

        /* ä½¿ç”¨è¯´æ˜å¼¹çª— - åœ£è¯ä¸»é¢˜ */
        #help-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            z-index: 300;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
            animation: fadeIn 0.3s ease-out;
        }

        #help-modal.show {
            display: flex;
        }

        .help-content {
            background: linear-gradient(135deg, #1a0a0e 0%, #0a1f14 100%);
            border: 3px solid #ffd700;
            border-radius: 20px;
            padding: 35px 40px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            scrollbar-width: none; /* Firefox éšè—æ»šåŠ¨æ¡ */
            box-shadow: 0 10px 50px rgba(196, 30, 58, 0.5), 0 0 40px rgba(255, 215, 0, 0.3);
            position: relative;
            animation: slideDown 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        /* WebKit æµè§ˆå™¨éšè—æ»šåŠ¨æ¡ï¼Œä»…ç”¨äºä½¿ç”¨è¯´æ˜å¼¹çª—å†…å®¹åŒºåŸŸ */
        .help-content::-webkit-scrollbar {
            width: 0;
            height: 0;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .help-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
        }

        .help-title {
            color: #ffd700;
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 2px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .help-close {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, #c41e3a 0%, #165b33 100%);
            border: 2px solid #ffd700;
            color: #ffd700;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .help-close:hover {
            transform: rotate(90deg) scale(1.1);
            background: #ffd700;
            color: #c41e3a;
        }

        .help-section {
            margin-bottom: 25px;
        }

        .help-section-title {
            color: #ffd700;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            letter-spacing: 1px;
        }

        .help-item {
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid #c41e3a;
            padding: 12px 16px;
            margin-bottom: 10px;
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 13px;
            line-height: 1.6;
            transition: all 0.3s ease;
        }

        .help-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-left-color: #ffd700;
            transform: translateX(5px);
        }

        .help-item strong {
            color: #ffd700;
            font-weight: 600;
        }

        .help-emoji {
            font-size: 20px;
            margin-right: 8px;
        }

        @media (max-width: 768px) {
            #toast-container {
                top: 10px;
                right: 10px;
                left: 10px;
            }

            .toast {
                min-width: auto;
                max-width: 100%;
                font-size: 12px;
                padding: 12px 16px;
            }

            #loading-toast {
                bottom: 50px;
                right: 10px;
                left: 10px;
                font-size: 10px;
                padding: 10px 15px;
            }

            #privacy-notice {
                font-size: 6px;
                padding: 6px 10px;
            }

            #help-btn {
                width: 45px;
                height: 45px;
                font-size: 20px;
            }

            .help-tooltip {
                display: none;
            }

            .help-content {
                padding: 25px 20px;
                max-height: 90vh;
            }

            .help-title {
                font-size: 18px;
            }

            .help-section-title {
                font-size: 14px;
            }

            #webcam-wrapper {
                width: 100px;
                height: 75px;
                bottom: 80px;
                left: 10px;
            }

            #mode-bar {
                bottom: 20px;
                right: 10px;
                gap: 10px;
            }

            .mode-btn {
                width: 48px;
                height: 48px;
                font-size: 20px;
            }
        }

        /* ä½¿ç”¨è¯´æ˜ / æ§åˆ¶æŒ‰é’®æç¤ºæ¡†ï¼ˆç§»åŠ¨ç«¯å‹å¥½ï¼‰ */
        #mode-tip {
            position: fixed;
            top: 80px;
            right: 88px;
            display: none;
            z-index: 260;
            pointer-events: none;
        }

        #mode-tip.show {
            display: flex;
        }

        .mode-tip-content {
            max-width: 320px;
            background: linear-gradient(135deg, rgba(10, 15, 25, 0.95) 0%, rgba(15, 35, 30, 0.95) 100%);
            border-radius: 16px;
            border: 2px solid rgba(200, 180, 120, 0.7);
            padding: 12px 14px;
            color: #fdfcf5;
            font-size: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            gap: 6px;
            pointer-events: auto;
        }

        .mode-tip-title {
            font-weight: 600;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 6px;
            color: #ffd666;
        }

        .mode-tip-text {
            line-height: 1.5;
        }

        .mode-tip-buttons {
            display: flex;
            justify-content: flex-end;
            margin-top: 4px;
        }

        #mode-tip-close {
            border: none;
            border-radius: 999px;
            padding: 4px 12px;
            font-size: 11px;
            cursor: pointer;
            background: linear-gradient(135deg, #c41e3a 0%, #165b33 100%);
            color: #fff;
            letter-spacing: 1px;
        }

        #mode-tip-close:active {
            transform: scale(0.96);
        }

        /* å·¦ä¸‹è§’ä¸Šä¼ æŒ‰é’® */
        #upload-btn {
            position: fixed;
            bottom: 30px;
            left: 20px;
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(160, 80, 90, 0.7) 0%, rgba(60, 100, 80, 0.7) 100%);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(200, 180, 120, 0.6);
            color: #f0f0f0;
            font-size: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(100, 60, 70, 0.3);
            z-index: 100;
        }
        #upload-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(100, 60, 70, 0.5);
            border-color: rgba(200, 180, 120, 0.9);
        }

        /* å›¾ç‰‡ç®¡ç†å¼¹çª— */
        #photo-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            z-index: 300;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        #photo-modal.show {
            display: flex;
        }
        .photo-modal-content {
            background: linear-gradient(135deg, #1a0a0e 0%, #0a1f14 100%);
            border: 3px solid #ffd700;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            scrollbar-width: none;
            box-shadow: 0 10px 50px rgba(196, 30, 58, 0.5);
        }
        .photo-modal-content::-webkit-scrollbar {
            width: 0;
            height: 0;
        }
        .photo-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 215, 0, 0.3);
        }
        .photo-modal-title {
            color: #ffd700;
            font-size: 20px;
            font-weight: 700;
            letter-spacing: 2px;
        }
        .photo-modal-close {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, #c41e3a 0%, #165b33 100%);
            border: 2px solid #ffd700;
            color: #ffd700;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        .photo-modal-close:hover {
            transform: rotate(90deg) scale(1.1);
            background: #ffd700;
            color: #c41e3a;
        }
        .photo-upload-area {
            margin-bottom: 20px;
        }
        .photo-upload-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 20px;
            border: 2px dashed rgba(255, 215, 0, 0.4);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.3s ease;
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }
        .photo-upload-label:hover {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }
        .photo-upload-label input {
            display: none;
        }
        .photo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }
        .photo-item {
            position: relative;
            aspect-ratio: 1;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        .photo-item:hover {
            border-color: #ffd700;
            transform: translateY(-3px);
        }
        .photo-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .photo-item-delete {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(255, 77, 79, 0.9);
            border: none;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .photo-item:hover .photo-item-delete {
            opacity: 1;
        }
        .photo-empty {
            text-align: center;
            padding: 30px;
            color: rgba(255, 255, 255, 0.5);
        }
        .photo-save-btn {
            width: 100%;
            padding: 14px;
            margin-top: 20px;
            border-radius: 12px;
            border: none;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #1a1a1a;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .photo-save-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(255, 215, 0, 0.5);
        }
        .photo-save-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        @media (max-width: 768px) {
            #upload-btn {
                bottom: 20px;
                left: 10px;
                width: 48px;
                height: 48px;
                font-size: 20px;
            }
            .photo-modal-content {
                padding: 20px;
                max-height: 90vh;
            }
            .photo-grid {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
                gap: 8px;
            }
        }
    </style>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div class="loader-scene">
            <div class="loader-moon"></div>
            <div class="loader-tree">
                <div class="tree-layer layer-1"></div>
                <div class="tree-layer layer-2"></div>
                <div class="tree-layer layer-3"></div>
                <div class="tree-trunk"></div>
                <div class="tree-star"></div>
                <div class="tree-ornament o1 gold"></div>
                <div class="tree-ornament o2"></div>
                <div class="tree-ornament o3 green"></div>
                <div class="tree-ornament o4 gold"></div>
                <div class="tree-ornament o5"></div>
                <div class="loader-garland"></div>
            </div>
            <div class="loader-present">
                <div class="loader-present-ribbon"></div>
            </div>
        </div>
        <div class="loader-text">
            <div class="loader-title">Merry Christmas</div>
            <div class="loader-subtitle">
                <span id="loader-model-name"></span> æ¨¡å‹æ­£åœ¨åŠ è½½ä¸­...
            </div>
        </div>
    </div>

    <!-- Toast é€šçŸ¥å®¹å™¨ -->
    <div id="toast-container"></div>

    <!-- åŠ è½½æç¤ºtoast -->
    <div id="loading-toast">
        <div class="toast-spinner"></div>
        <div class="toast-text">Loading AI Model...</div>
    </div>

    <!-- éšç§è¯´æ˜ -->
    <div id="privacy-notice">
        æ‘„åƒå¤´ä»…ç”¨äºæ‰‹åŠ¿è¯†åˆ«ã€‚
    </div>

    <!-- å·¦ä¸‹è§’ä¸Šä¼ æŒ‰é’® -->
    <div id="upload-btn" title="ç®¡ç†ç…§ç‰‡">ğŸ“·</div>

    <!-- å›¾ç‰‡ç®¡ç†å¼¹çª— -->
    <div id="photo-modal">
        <div class="photo-modal-content">
            <div class="photo-modal-header">
                <div class="photo-modal-title">ğŸ„ ç…§ç‰‡ç®¡ç†</div>
                <div class="photo-modal-close">Ã—</div>
            </div>
            <div class="photo-upload-area">
                <label class="photo-upload-label">
                    <span>ğŸ“</span>
                    <span>ç‚¹å‡»ä¸Šä¼ æ–°ç…§ç‰‡ï¼ˆå¯å¤šé€‰ï¼‰</span>
                    <input type="file" id="photo-input" multiple accept="image/*">
                </label>
            </div>
            <div class="photo-grid" id="photo-grid">
                <div class="photo-empty">æš‚æ— ç…§ç‰‡ï¼Œä¸Šä¼ ä¸€äº›å§~</div>
            </div>
            <button class="photo-save-btn" id="photo-save-btn">ä¿å­˜å¹¶åˆ·æ–°</button>
        </div>
    </div>

    <!-- å³ä¸‹è§’æŒ‰é’®æç¤ºæ¡† -->
    <div id="mode-tip">
        <div class="mode-tip-content">
            <div class="mode-tip-title">
                <span>ğŸ® å°æç¤º</span>
            </div>
            <div class="mode-tip-text">
                å³ä¸‹è§’æœ‰æ§åˆ¶æŒ‰é’®ï¼šğŸ“· å¼€å…³æ‘„åƒå¤´ã€ğŸ„ æ ‘å½¢æ¨¡å¼ã€âœ¨ æ˜Ÿäº‘æ¨¡å¼ã€ğŸ” éšæœºç…§ç‰‡ã€ğŸ™ˆ éšè—/æ˜¾ç¤ºç•Œé¢ï¼ˆé€‚åˆæˆªå›¾/å½•å±ï¼‰ã€‚æ›´è¯¦ç»†çš„æ‰‹åŠ¿æ“ä½œè¯´æ˜ï¼Œè¯·ç‚¹å‡»å³ä¸Šè§’ ğŸ’¡ã€Œä½¿ç”¨è¯´æ˜ã€æŒ‰é’®æŸ¥çœ‹ã€‚
            </div>
            <div class="mode-tip-buttons">
                <button id="mode-tip-close">æˆ‘çŸ¥é“äº†</button>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- ä½¿ç”¨è¯´æ˜æŒ‰é’® -->
    <div id="help-btn">
        ğŸ’¡
        <div class="help-tooltip">å¦‚ä½•ä½¿ç”¨ï¼Ÿç‚¹ç‚¹æˆ‘</div>
    </div>

    <!-- ä½¿ç”¨è¯´æ˜å¼¹çª— -->
    <div id="help-modal">
        <div class="help-content">
            <div class="help-header">
                <div class="help-title">
                    ğŸ„ ä½¿ç”¨è¯´æ˜
                </div>
                <div class="help-close">Ã—</div>
            </div>

            <div class="help-section">
                <div class="help-section-title">
                    <span>ğŸ¤š</span> æ‰‹åŠ¿è¯†åˆ«æ§åˆ¶ï¼ˆæ¨èï¼ï¼ï¼ï¼‰
                </div>
                <div class="help-item">
                    <strong>å¼ å¼€æ‰‹æŒ (ğŸ–ï¸)ï¼š</strong>ç‚¸è£‚æ¨¡å¼ï¼ç²’å­æ•£å¼€æˆæ˜Ÿäº‘æ•ˆæœ
                </div>
                <div class="help-item">
                    <strong>æ¡ç´§æ‹³å¤´ (âœŠ)ï¼š</strong>æ”¶æ‹¢æ¨¡å¼ï¼ç²’å­é‡æ–°èšåˆæˆåœ£è¯æ ‘
                </div>
                <div class="help-item">
                    <strong>æåˆæ‰‹æŒ‡ (ğŸ¤)ï¼š</strong>éšæœºå±•ç¤ºä¸€å¼ ç…§ç‰‡
                </div>
            </div>


            <div class="help-section">
                <div class="help-section-title">
                    <span>ğŸ–±ï¸</span> é¼ æ ‡/è§¦æ‘¸æ§åˆ¶
                </div>
                <div class="help-item">
                    <strong>æ‹–æ‹½æ—‹è½¬ï¼š</strong>æŒ‰ä½é¼ æ ‡å·¦é”®æˆ–å•æŒ‡æ‹–åŠ¨ï¼Œå¯æ—‹è½¬åœ£è¯æ ‘
                </div>
                <div class="help-item">
                    <strong>ç¼©æ”¾è§†å›¾ï¼š</strong>ä½¿ç”¨é¼ æ ‡æ»šè½®æˆ–åŒæŒ‡ç¼©æ”¾
                </div>
                <div class="help-item">
                    <strong>ç‚¹å‡»ç…§ç‰‡ï¼š</strong>ç‚¹å‡»æ ‘ä¸Šçš„ç…§ç‰‡å¯æŸ¥çœ‹å¤§å›¾
                </div>
            </div>

            <div class="help-section">
                <div class="help-section-title">
                    <span>ğŸ®</span> å³ä¸‹è§’æ§åˆ¶æŒ‰é’®
                </div>
                <div class="help-item">
                    <strong>ğŸ“· ç›¸æœºæŒ‰é’®ï¼š</strong>å¼€å¯/å…³é—­æ‘„åƒå¤´ï¼Œé‡è½½æ‰‹åŠ¿è¯†åˆ«
                </div>
                <div class="help-item">
                    <strong>ğŸ„ æ ‘å½¢æŒ‰é’®ï¼š</strong>åˆ‡æ¢åˆ°åœ£è¯æ ‘æ¨¡å¼
                </div>
                <div class="help-item">
                    <strong>âœ¨ æ˜Ÿäº‘æŒ‰é’®ï¼š</strong>åˆ‡æ¢åˆ°ç²’å­ç‚¸è£‚æ¨¡å¼
                </div>
                <div class="help-item">
                    <strong>ğŸ” èšç„¦æŒ‰é’®ï¼š</strong>éšæœºèšç„¦ä¸€å¼ ç…§ç‰‡
                </div>
            </div>

            <div class="help-section">
                <div class="help-section-title">
                    <span>âŒ¨ï¸</span> é”®ç›˜å¿«æ·é”®
                </div>
                <div class="help-item">
                    <strong>H é”®ï¼š</strong>éšè—æ‰€æœ‰UIç•Œé¢ï¼Œé€‚åˆæˆªå›¾æˆ–å½•å±
                </div>
            </div>

            <div class="help-item" style="background: rgba(196, 30, 58, 0.2); border-left-color: #ffd700; text-align: center; margin-top: 20px;">
                <span class="help-emoji">ğŸ…</span>
                <strong>Powerd By kk</strong>
                <span class="help-emoji">ğŸ„</span>
            </div>
        </div>
    </div>

    <div id="ui-layer">
        <h1>Merry Christmas</h1>

        <!-- å³ä¸‹è§’æ¨¡å¼åˆ‡æ¢æŒ‰é’® -->
        <div id="mode-bar">
            <div class="mode-btn" onclick="reloadCamera()" title="é‡è½½æ‘„åƒå¤´">ğŸ“·</div>
            <div class="mode-btn" onclick="setMode('TREE')" title="åœ£è¯æ ‘æ¨¡å¼">ğŸ„</div>
            <div class="mode-btn" onclick="setMode('SCATTER')" title="ç‚¸è£‚æ¨¡å¼">âœ¨</div>
            <div class="mode-btn" onclick="setMode('FOCUS_RANDOM')" title="èšç„¦æ¨¡å¼">ğŸ”</div>
            <div class="mode-btn" onclick="toggleUIVisibility()" title="éšè—/æ˜¾ç¤ºç•Œé¢">ğŸ™ˆ</div>
        </div>
    </div>

    <div id="webcam-wrapper">
        <video id="webcam" autoplay playsinline webkit-playsinline></video>
    </div>
    <div id="debug-info">Drag to rotate â€¢ Tap photo to view</div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js'; 
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        const HAND_MODEL_NAME = 'MediaPipe Hand Landmarker';
        const FOCUS_SCALE = 2.0;
        const CONFIG = {
            colors: {
                bg: 0x050d1a, 
                fog: 0x050d1a,
                champagneGold: 0xffd966, 
                deepGreen: 0x03180a,     
                accentRed: 0x990000,     
            },
            particles: {
                count: 1500,
                dustCount: 2000,
                treeHeight: 24,
                treeRadius: 8
            },
            camera: { z: 50 },
            preload: {
                autoScanLocal: false,
                useCloudImages: true,
                cloudImageUrls: [],
                scanCount: 200
            }
        };

        const IS_WECHAT = /MicroMessenger/i.test(navigator.userAgent || '');
        let currentPhotos = []; // å½“å‰å·²æœ‰çš„ç…§ç‰‡åˆ—è¡¨
        let pendingFiles = [];  // å¾…ä¸Šä¼ çš„æ–‡ä»¶åˆ—è¡¨

        const STATE = {
            mode: 'TREE', 
            focusIndex: -1, 
            focusTarget: null,
            hand: { detected: false, x: 0, y: 0 },
            rotation: { x: 0, y: 0 },
            touch: { active: false, startX: 0, startY: 0, lastX: 0, lastY: 0 }
        };

        let scene, camera, renderer, composer;
        let mainGroup;
        let clock = new THREE.Clock();
        let particleSystem = [];
        let photoMeshGroup = new THREE.Group();
        let handLandmarker, video;
        let caneTexture;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        const TMP_VEC3_A = new THREE.Vector3();
        const TMP_VEC3_B = new THREE.Vector3();
        const TMP_MAT4_A = new THREE.Matrix4();
        
        const debugInfo = document.getElementById('debug-info');
        const loaderModelSpan = document.getElementById('loader-model-name');
        if (loaderModelSpan) {
            loaderModelSpan.textContent = HAND_MODEL_NAME;
        }
        let isCameraRunning = false;

        window.toggleUIVisibility = () => {
            const webcam = document.getElementById('webcam-wrapper');
            if (webcam) webcam.classList.toggle('ui-hidden');
            const helpButton = document.getElementById('help-btn');
            if (helpButton) helpButton.classList.toggle('ui-hidden');
            const privacy = document.getElementById('privacy-notice');
            if (privacy) privacy.classList.toggle('ui-hidden');
            const modeBar = document.getElementById('mode-bar');
            if (modeBar) modeBar.classList.toggle('ui-hidden');
            const title = document.querySelector('h1');
            if (title) title.classList.toggle('ui-hidden');
            const uploadBtn = document.getElementById('upload-btn');
            if (uploadBtn) uploadBtn.classList.toggle('ui-hidden');
        };

        window.setMode = (mode) => {
            if (mode === 'FOCUS_RANDOM') {
                STATE.mode = 'FOCUS';
                const photos = particleSystem.filter(p => p.type === 'PHOTO');
                if (photos.length) STATE.focusTarget = photos[Math.floor(Math.random()*photos.length)].mesh;
            } else {
                STATE.mode = mode;
                if (mode === 'TREE') STATE.focusTarget = null;
            }
        };

        // é‡è½½æ‘„åƒå¤´å‡½æ•°
        window.reloadCamera = () => {
            if (isCameraRunning) {
                // åœæ­¢å½“å‰æ‘„åƒå¤´
                if (video && video.srcObject) {
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    video.srcObject = null;
                }
                isCameraRunning = false;
                document.getElementById('webcam-wrapper').style.opacity = 0;
                showToast('æ‘„åƒå¤´å·²å…³é—­', 'info', 2000);
            } else {
                // é‡æ–°å¯åŠ¨æ‘„åƒå¤´
                initMediaPipe();
            }
        };

        function setupModeBarTip() {
            const tip = document.getElementById('mode-tip');
            const closeBtn = document.getElementById('mode-tip-close');
            if (!tip || !closeBtn) return null;

            const STORAGE_KEY = 'tree_mode_tip_shown_v1';
            if (window.localStorage && localStorage.getItem(STORAGE_KEY) === '1') {
                return null;
            }

            closeBtn.addEventListener('click', () => {
                tip.classList.remove('show');
                if (window.localStorage) {
                    localStorage.setItem(STORAGE_KEY, '1');
                }
            });

            const show = () => {
                tip.classList.add('show');
            };

            return show;
        }

        async function init() {
            const showModeTip = setupModeBarTip();

            initThree();
            setupEnvironment();
            setupLights();
            createTextures();
            createParticles();
            createDust();
            createMagicParticles();   // é­”æ³•ç²’å­
            createSparkles();          // é—ªçƒæ˜Ÿå…‰
            createRingParticles();     // å…‰ç¯ç²’å­
            loadPredefinedImages();
            setupPostProcessing();
            setupEvents();
            setupTouchAndClick();
            setupPhotoModal(); // è®¾ç½®å›¾ç‰‡ç®¡ç†å¼¹çª—

            const loader = document.getElementById('loader');
            loader.style.opacity = 0;
            setTimeout(() => {
                loader.remove();
                if (typeof showModeTip === 'function') {
                    setTimeout(() => showModeTip(), 300);
                }
                // é¡µé¢åŠ è½½å®Œæˆåå°è¯•è‡ªåŠ¨å¯åŠ¨æ‘„åƒå¤´
                if (!IS_WECHAT) {
                    setTimeout(() => initMediaPipe(), 500);
                } else {
                    showToast('è¯·ç‚¹å‡»å³ä¸‹è§’ğŸ“·æŒ‰é’®å¼€å¯æ‰‹åŠ¿è¯†åˆ«', 'info', 4000);
                }
            }, 800);

            animate();
        }

        // --- è§¦å±ä¸ç‚¹å‡»é€»è¾‘ (Raycaster) ---
        function setupTouchAndClick() {
            const container = document.getElementById('canvas-container');
            
            container.addEventListener('pointerdown', (e) => {
                STATE.touch.active = true;
                STATE.touch.startX = e.clientX;
                STATE.touch.startY = e.clientY;
                STATE.touch.lastX = e.clientX;
                STATE.touch.lastY = e.clientY;
            });

            window.addEventListener('pointermove', (e) => {
                if (!STATE.touch.active) return;
                const deltaX = e.clientX - STATE.touch.lastX;
                const deltaY = e.clientY - STATE.touch.lastY;
                STATE.rotation.y += deltaX * 0.005;
                STATE.rotation.x += deltaY * 0.002;
                STATE.rotation.x = Math.max(-0.5, Math.min(0.5, STATE.rotation.x));
                STATE.touch.lastX = e.clientX;
                STATE.touch.lastY = e.clientY;
            });

            window.addEventListener('pointerup', (e) => {
                STATE.touch.active = false;
            });

            container.addEventListener('click', (e) => {
                const moveDist = Math.hypot(e.clientX - STATE.touch.startX, e.clientY - STATE.touch.startY);
                if (moveDist > 10) return; 

                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const intersects = raycaster.intersectObjects(mainGroup.children, true);

                let clickedPhoto = null;
                for (let hit of intersects) {
                    let obj = hit.object;
                    while(obj.parent && obj.parent !== mainGroup && obj.parent !== photoMeshGroup) {
                        obj = obj.parent;
                    }
                    const particle = particleSystem.find(p => p.mesh === obj && p.type === 'PHOTO');
                    if (particle) {
                        clickedPhoto = particle;
                        break;
                    }
                }

                if (clickedPhoto) {
                    STATE.mode = 'FOCUS';
                    STATE.focusTarget = clickedPhoto.mesh;
                } else {
                    if (STATE.mode === 'FOCUS') {
                        STATE.mode = 'TREE';
                        STATE.focusTarget = null;
                    }
                }
            });

            let lastTap = 0;
            container.addEventListener('touchend', (e) => {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTap;
                if (tapLength < 300 && tapLength > 0) {
                    STATE.mode = (STATE.mode === 'SCATTER') ? 'TREE' : 'SCATTER';
                    e.preventDefault();
                }
                lastTap = currentTime;
            });
        }

        // --- æ ¸å¿ƒ Three.js é€»è¾‘ ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.colors.bg);
            scene.fog = new THREE.FogExp2(CONFIG.colors.fog, 0.015);

            camera = new THREE.PerspectiveCamera(42, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, CONFIG.camera.z); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping; 
            renderer.toneMappingExposure = 2.2; 
            container.appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);
        }

        function setupEnvironment() {
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        }

        function setupLights() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.6); 
            scene.add(ambient);
            const innerLight = new THREE.PointLight(0xffaa00, 2, 20);
            innerLight.position.set(0, 5, 0);
            mainGroup.add(innerLight);
            const spotGold = new THREE.SpotLight(0xffcc66, 1200);
            spotGold.position.set(30, 40, 40); spotGold.angle = 0.5; spotGold.penumbra = 0.5;
            scene.add(spotGold);
            const spotBlue = new THREE.SpotLight(0x6688ff, 800); 
            spotBlue.position.set(-30, 20, -30);
            scene.add(spotBlue);
            const fill = new THREE.DirectionalLight(0xffeebb, 0.8);
            fill.position.set(0, 0, 50);
            scene.add(fill);
        }

        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.65; bloomPass.strength = 0.5; bloomPass.radius = 0.4;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        function createTextures() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#880000'; ctx.beginPath();
            for(let i=-128; i<256; i+=32) {
                ctx.moveTo(i, 0); ctx.lineTo(i+32, 128); ctx.lineTo(i+16, 128); ctx.lineTo(i-16, 0);
            }
            ctx.fill();
            caneTexture = new THREE.CanvasTexture(canvas);
            caneTexture.wrapS = THREE.RepeatWrapping; caneTexture.wrapT = THREE.RepeatWrapping;
            caneTexture.repeat.set(3, 3);
        }

        // --- ç²’å­ä¸å›¾ç‰‡ç³»ç»Ÿ ---
        // DOM-based é›ªèŠ±æ•ˆæœ (åŒ¹é… config.html)
        function createSnowflake() {
            const snowflake = document.createElement('div');
            snowflake.className = 'snowflake';
            snowflake.textContent = 'â„';
            snowflake.style.left = Math.random() * 100 + '%';
            snowflake.style.animationDuration = (Math.random() * 3 + 2) + 's';
            snowflake.style.fontSize = (Math.random() * 10 + 10) + 'px';
            snowflake.style.opacity = Math.random() * 0.6 + 0.4;
            document.body.appendChild(snowflake);

            setTimeout(() => {
                snowflake.remove();
            }, 5000);
        }

        // æ¯300msåˆ›å»ºä¸€ä¸ªé›ªèŠ±
        setInterval(createSnowflake, 300);

        class Particle {
            constructor(mesh, type, isDust = false) {
                this.mesh = mesh; this.type = type; this.isDust = isDust;
                this.posTree = new THREE.Vector3(); this.posScatter = new THREE.Vector3();
                this.baseScale = mesh.scale.x; 
                const speedMult = (type === 'PHOTO') ? 0.3 : 2.0;
                this.spinSpeed = new THREE.Vector3((Math.random()-0.5)*speedMult, (Math.random()-0.5)*speedMult, (Math.random()-0.5)*speedMult);
                this.calculatePositions();
            }
            calculatePositions() {
                if (this.type === 'PHOTO') {
                    this.posTree.set(0, 0, 0); 
                    const rScatter = 8 + Math.random()*12;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    this.posScatter.set(rScatter * Math.sin(phi) * Math.cos(theta), rScatter * Math.sin(phi) * Math.sin(theta), rScatter * Math.cos(phi));
                    return;
                }
                const h = CONFIG.particles.treeHeight;
                let t = Math.pow(Math.random(), 0.8); 
                const y = (t * h) - (h / 2);
                let rMax = Math.max(0.5, CONFIG.particles.treeRadius * (1.0 - t));
                const angle = t * 50 * Math.PI + Math.random() * Math.PI; 
                const r = rMax * (0.8 + Math.random() * 0.4); 
                this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
                let rScatter = this.isDust ? (12 + Math.random()*20) : (8 + Math.random()*12);
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(rScatter * Math.sin(phi) * Math.cos(theta), rScatter * Math.sin(phi) * Math.sin(theta), rScatter * Math.cos(phi));
            }
            update(dt, mode, focusTargetMesh) {
                let target = (mode === 'SCATTER') ? this.posScatter : this.posTree;
                if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) {
                        // æ ¹æ®å±å¹•æ¯”ä¾‹ä¸ºç§»åŠ¨ç«¯å’Œæ¡Œé¢åˆ†åˆ«è®¾å®šèšç„¦ä½ç½®
                        const isPortrait = window.innerHeight > window.innerWidth;
                        const desiredWorldPos = isPortrait
                            ? new THREE.Vector3(-2.2, 1.2, 40)   // ç§»åŠ¨ç«¯ï¼šç¨è¿œä¸€ç‚¹é˜²æ­¢è£åˆ‡
                            : new THREE.Vector3(0, 1, 35);    // æ¡Œé¢ç«¯
                        const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
                        target = desiredWorldPos.applyMatrix4(invMatrix);
                    } else target = this.posScatter;
                }
                const lerpSpeed = (mode === 'FOCUS' && this.mesh === focusTargetMesh) ? 5.0 : 2.0; 
                this.mesh.position.lerp(target, lerpSpeed * dt);

                if (mode === 'SCATTER') {
                    this.mesh.rotation.x += this.spinSpeed.x * dt;
                    this.mesh.rotation.y += this.spinSpeed.y * dt;
                    this.mesh.rotation.z += this.spinSpeed.z * dt; 
                } else if (mode === 'TREE') {
                    if (this.type === 'PHOTO') {
                        this.mesh.lookAt(0, this.mesh.position.y, 0);
                        this.mesh.rotateY(Math.PI);
                    } else {
                        this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, dt);
                        this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, 0, dt);
                        this.mesh.rotation.y += 0.5 * dt; 
                    }
                }
                if (mode === 'FOCUS' && this.mesh === focusTargetMesh) this.mesh.lookAt(camera.position); 

                let s = this.baseScale;
                if (this.isDust) {
                    s = this.baseScale * (0.8 + 0.4 * Math.sin(clock.elapsedTime * 4 + this.mesh.id));
                    if (mode === 'TREE') s = 0; 
                } else if (mode === 'SCATTER' && this.type === 'PHOTO') s = this.baseScale * 2.5; 
                else if (mode === 'FOCUS') {
                    const isPortrait = window.innerHeight > window.innerWidth;
                    if (this.mesh === focusTargetMesh) {
                        // ç§»åŠ¨ç«¯ç•¥å°ä¸€ç‚¹ï¼Œæ¡Œé¢ä½¿ç”¨å…¨å±€ FOCUS_SCALE
                        s = isPortrait ? 2.4 : FOCUS_SCALE;
                    } else {
                        s = this.baseScale * 1.0;
                    }
                }
                this.mesh.scale.lerp(new THREE.Vector3(s,s,s), 4*dt);
            }
        }

        function updatePhotoLayout() {
            const photos = particleSystem.filter(p => p.type === 'PHOTO');
            const count = photos.length;
            if (count === 0) return;
            const h = CONFIG.particles.treeHeight * 0.9;
            const bottomY = -h/2; const stepY = h / count; const loops = 3;
            photos.forEach((p, i) => {
                const y = bottomY + stepY * i + stepY/2;
                const normalizedH = (y + h/2) / CONFIG.particles.treeHeight; 
                const r = Math.max(1.0, CONFIG.particles.treeRadius * (1.0 - normalizedH)) + 3.0; 
                const angle = normalizedH * Math.PI * 2 * loops + (Math.PI/4); 
                p.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
            });
        }

        function createParticles() {
            const sphereGeo = new THREE.SphereGeometry(0.5, 32, 32); 
            const boxGeo = new THREE.BoxGeometry(0.55, 0.55, 0.55); 
            const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.3, 0), new THREE.Vector3(0.1, 0.5, 0), new THREE.Vector3(0.3, 0.4, 0)]);
            const candyGeo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false);
            const goldMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.champagneGold, metalness: 1.0, roughness: 0.1, envMapIntensity: 2.0, emissive: 0x443300, emissiveIntensity: 0.3 });
            const greenMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.deepGreen, metalness: 0.2, roughness: 0.8, emissive: 0x002200, emissiveIntensity: 0.2 });
            const redMat = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.accentRed, metalness: 0.3, roughness: 0.2, clearcoat: 1.0, emissive: 0x330000 });
            const candyMat = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.4 });

            for (let i = 0; i < CONFIG.particles.count; i++) {
                const rand = Math.random();
                let mesh, type;
                if (rand < 0.40) { mesh = new THREE.Mesh(boxGeo, greenMat); type = 'BOX'; }
                else if (rand < 0.70) { mesh = new THREE.Mesh(boxGeo, goldMat); type = 'GOLD_BOX'; }
                else if (rand < 0.92) { mesh = new THREE.Mesh(sphereGeo, goldMat); type = 'GOLD_SPHERE'; }
                else if (rand < 0.97) { mesh = new THREE.Mesh(sphereGeo, redMat); type = 'RED'; }
                else { mesh = new THREE.Mesh(candyGeo, candyMat); type = 'CANE'; }
                const s = 0.4 + Math.random() * 0.5;
                mesh.scale.set(s,s,s); mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
                mainGroup.add(mesh);
                particleSystem.push(new Particle(mesh, type, false));
            }
            // Star
            const starShape = new THREE.Shape();
            const points = 5;
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI) / points + Math.PI / 2;
                const r = (i % 2 === 0) ? 1.5 : 0.7;
                const x = Math.cos(angle) * r; const y = Math.sin(angle) * r;
                if (i === 0) starShape.moveTo(x, y); else starShape.lineTo(x, y);
            }
            starShape.closePath();
            const starGeo = new THREE.ExtrudeGeometry(starShape, { depth: 0.4, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 2 });
            starGeo.center(); 
            const starMat = new THREE.MeshStandardMaterial({ color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 1.0, metalness: 1.0, roughness: 0 });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, CONFIG.particles.treeHeight/2 + 1.2, 0);
            mainGroup.add(star);
            mainGroup.add(photoMeshGroup);
        }

        function createDust() {
            const geo = new THREE.TetrahedronGeometry(0.08, 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffeebb, transparent: true, opacity: 0.8 });
            for(let i=0; i<CONFIG.particles.dustCount; i++) {
                 const mesh = new THREE.Mesh(geo, mat);
                 mesh.scale.setScalar(0.5 + Math.random());
                 mainGroup.add(mesh);
                 particleSystem.push(new Particle(mesh, 'DUST', true));
            }
        }

        // åˆ›å»ºé­”æ³•ç²’å­ç³»ç»Ÿï¼ˆèºæ—‹ä¸Šå‡çš„å‘å…‰ç²’å­ï¼‰
        let magicParticles = [];
        function createMagicParticles() {
            const colors = [0xff6b6b, 0xffd93d, 0x6bcb77, 0x4d96ff, 0xff6bff, 0xffffff];
            const particleCount = 150;
            
            for (let i = 0; i < particleCount; i++) {
                const geo = new THREE.SphereGeometry(0.05 + Math.random() * 0.08, 8, 8);
                const color = colors[Math.floor(Math.random() * colors.length)];
                const mat = new THREE.MeshBasicMaterial({ 
                    color: color, 
                    transparent: true, 
                    opacity: 0.8 
                });
                const mesh = new THREE.Mesh(geo, mat);
                
                // åˆå§‹ä½ç½®åœ¨æ ‘çš„èŒƒå›´å†…
                const angle = Math.random() * Math.PI * 2;
                const radius = 2 + Math.random() * 6;
                const y = -12 + Math.random() * 24;
                mesh.position.set(
                    Math.cos(angle) * radius,
                    y,
                    Math.sin(angle) * radius
                );
                
                mainGroup.add(mesh);
                magicParticles.push({
                    mesh,
                    baseAngle: angle,
                    baseRadius: radius,
                    speed: 0.3 + Math.random() * 0.5,
                    phase: Math.random() * Math.PI * 2,
                    color: color
                });
            }
        }

        // åˆ›å»ºé—ªçƒæ˜Ÿå…‰ç²’å­
        let sparkleParticles = [];
        function createSparkles() {
            const sparkleCount = 80;
            
            for (let i = 0; i < sparkleCount; i++) {
                // åˆ›å»ºåå­—å½¢æ˜Ÿå…‰
                const group = new THREE.Group();
                const mat = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff, 
                    transparent: true, 
                    opacity: 0.9 
                });
                
                const h1 = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.15, 0.02), mat);
                const h2 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.02, 0.02), mat);
                group.add(h1);
                group.add(h2);
                
                // éšæœºä½ç½®åœ¨æ ‘å½¢èŒƒå›´å†…
                const t = Math.random();
                const y = (t * CONFIG.particles.treeHeight) - (CONFIG.particles.treeHeight / 2);
                const maxR = CONFIG.particles.treeRadius * (1.0 - t) + 1;
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * maxR;
                
                group.position.set(
                    Math.cos(angle) * r,
                    y,
                    Math.sin(angle) * r
                );
                
                mainGroup.add(group);
                sparkleParticles.push({
                    mesh: group,
                    phase: Math.random() * Math.PI * 2,
                    twinkleSpeed: 2 + Math.random() * 4
                });
            }
        }

        // åˆ›å»ºå…‰ç¯ç²’å­ï¼ˆå›´ç»•æ ‘æ—‹è½¬çš„å…‰å¸¦ï¼‰
        let ringParticles = [];
        function createRingParticles() {
            const ringCount = 5; // å…‰ç¯å±‚æ•°
            const particlesPerRing = 40;
            const colors = [0xffd700, 0xff6b6b, 0x4ecdc4, 0xffffff, 0xff69b4];
            
            for (let ring = 0; ring < ringCount; ring++) {
                const y = -8 + ring * 5;
                const radius = 6 - ring * 0.8;
                const color = colors[ring];
                
                for (let i = 0; i < particlesPerRing; i++) {
                    const geo = new THREE.SphereGeometry(0.06, 6, 6);
                    const mat = new THREE.MeshBasicMaterial({ 
                        color: color, 
                        transparent: true, 
                        opacity: 0.7 
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    
                    const angle = (i / particlesPerRing) * Math.PI * 2;
                    mesh.position.set(
                        Math.cos(angle) * radius,
                        y,
                        Math.sin(angle) * radius
                    );
                    
                    mainGroup.add(mesh);
                    ringParticles.push({
                        mesh,
                        ring,
                        baseAngle: angle,
                        radius,
                        y,
                        speed: 0.5 + ring * 0.2
                    });
                }
            }
        }

        // æ›´æ–°é­”æ³•ç²’å­
        function updateMagicParticles(time) {
            magicParticles.forEach((p, i) => {
                // èºæ—‹ä¸Šå‡
                p.mesh.position.y += p.speed * 0.02;
                if (p.mesh.position.y > 14) {
                    p.mesh.position.y = -12;
                }
                
                // èºæ—‹è¿åŠ¨
                const newAngle = p.baseAngle + time * p.speed + p.phase;
                const wobble = Math.sin(time * 2 + p.phase) * 0.5;
                p.mesh.position.x = Math.cos(newAngle) * (p.baseRadius + wobble);
                p.mesh.position.z = Math.sin(newAngle) * (p.baseRadius + wobble);
                
                // é—ªçƒæ•ˆæœ
                p.mesh.material.opacity = 0.4 + Math.sin(time * 3 + p.phase) * 0.4;
                
                // ç¼©æ”¾è„‰åŠ¨
                const scale = 0.8 + Math.sin(time * 4 + p.phase) * 0.3;
                p.mesh.scale.setScalar(scale);
            });
        }

        // æ›´æ–°é—ªçƒæ˜Ÿå…‰
        function updateSparkles(time) {
            sparkleParticles.forEach(p => {
                // é—ªçƒ
                const twinkle = Math.sin(time * p.twinkleSpeed + p.phase);
                p.mesh.children.forEach(child => {
                    child.material.opacity = 0.3 + twinkle * 0.6;
                });
                
                // æ—‹è½¬
                p.mesh.rotation.z = time * 2 + p.phase;
                
                // ç¼©æ”¾è„‰åŠ¨
                const scale = 0.5 + twinkle * 0.5;
                p.mesh.scale.setScalar(scale);
            });
        }

        // æ›´æ–°å…‰ç¯ç²’å­
        function updateRingParticles(time) {
            ringParticles.forEach(p => {
                const angle = p.baseAngle + time * p.speed;
                p.mesh.position.x = Math.cos(angle) * p.radius;
                p.mesh.position.z = Math.sin(angle) * p.radius;
                
                // ä¸Šä¸‹æ³¢åŠ¨
                p.mesh.position.y = p.y + Math.sin(angle * 3) * 0.3;
                
                // é€æ˜åº¦å˜åŒ–
                p.mesh.material.opacity = 0.4 + Math.sin(angle * 2) * 0.3;
            });
        }

        function addPhotoToScene(texture) {
            const frameGeo = new THREE.BoxGeometry(1.4, 1.4, 0.05);
            const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.champagneGold, metalness: 1.0, roughness: 0.1 });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            let width = 1.2; let height = 1.2;
            if (texture.image) {
                const aspect = texture.image.width / texture.image.height;
                if (aspect > 1) height = width / aspect; else width = height * aspect;
            }
            const photoGeo = new THREE.PlaneGeometry(width, height);
            const photoMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.04;
            const group = new THREE.Group();
            group.add(frame); group.add(photo);
            frame.scale.set(width/1.2, height/1.2, 1);
            const s = 1.1; group.scale.set(s,s,s);
            photoMeshGroup.add(group);
            particleSystem.push(new Particle(group, 'PHOTO', false));
            updatePhotoLayout();
        }

        function handleImageUpload(e) {
            const files = e.target.files;
            if(!files.length) return;
            Array.from(files).forEach(f => {
                if (!f.type.startsWith('image/')) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    new THREE.TextureLoader().load(ev.target.result, (t) => {
                        t.colorSpace = THREE.SRGBColorSpace;
                        addPhotoToScene(t);
                    });
                }
                reader.readAsDataURL(f);
            });
        }
        
        async function loadPredefinedImages() {
            const loader = new THREE.TextureLoader();

            // ä»æœåŠ¡å™¨åŠ è½½ç…§ç‰‡
            try {
                const resp = await fetch('/api/photos');
                if (resp.ok) {
                    const data = await resp.json();
                    if (Array.isArray(data.photos)) {
                        currentPhotos = data.photos;
                        data.photos.forEach((url) => {
                            loader.load(
                                url,
                                (t) => {
                                    t.colorSpace = THREE.SRGBColorSpace;
                                    addPhotoToScene(t);
                                },
                                undefined,
                                () => {}
                            );
                        });
                    }
                }
            } catch (e) {
                console.warn('Failed to load photos', e);
            }
        }

        // æ¸…é™¤æ‰€æœ‰ç…§ç‰‡å¹¶é‡æ–°åŠ è½½
        function reloadPhotos() {
            // æ¸…é™¤ç°æœ‰çš„ç…§ç‰‡mesh
            const photosToRemove = particleSystem.filter(p => p.type === 'PHOTO');
            photosToRemove.forEach(p => {
                photoMeshGroup.remove(p.mesh);
            });
            particleSystem = particleSystem.filter(p => p.type !== 'PHOTO');
            
            // é‡æ–°åŠ è½½
            loadPredefinedImages();
        }

        // å›¾ç‰‡ç®¡ç†å¼¹çª—é€»è¾‘
        function setupPhotoModal() {
            const uploadBtn = document.getElementById('upload-btn');
            const photoModal = document.getElementById('photo-modal');
            const modalClose = photoModal.querySelector('.photo-modal-close');
            const photoInput = document.getElementById('photo-input');
            const photoGrid = document.getElementById('photo-grid');
            const saveBtn = document.getElementById('photo-save-btn');

            // æ‰“å¼€å¼¹çª—
            uploadBtn.addEventListener('click', () => {
                pendingFiles = [];
                renderPhotoGrid();
                photoModal.classList.add('show');
            });

            // å…³é—­å¼¹çª—
            modalClose.addEventListener('click', () => {
                photoModal.classList.remove('show');
            });
            photoModal.addEventListener('click', (e) => {
                if (e.target === photoModal) {
                    photoModal.classList.remove('show');
                }
            });

            // é€‰æ‹©æ–‡ä»¶
            photoInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                pendingFiles = [...pendingFiles, ...files];
                renderPhotoGrid();
                photoInput.value = '';
            });

            // ä¿å­˜æŒ‰é’®
            saveBtn.addEventListener('click', async () => {
                if (pendingFiles.length === 0) {
                    photoModal.classList.remove('show');
                    return;
                }

                saveBtn.disabled = true;
                saveBtn.textContent = 'ä¸Šä¼ ä¸­...';

                const formData = new FormData();
                pendingFiles.forEach(f => formData.append('photos', f));

                try {
                    const resp = await fetch('/api/photos', {
                        method: 'POST',
                        body: formData
                    });
                    const data = await resp.json();
                    if (data.ok) {
                        currentPhotos = data.photos;
                        showToast('ä¸Šä¼ æˆåŠŸï¼', 'success', 2000);
                        reloadPhotos();
                        photoModal.classList.remove('show');
                    } else {
                        showToast('ä¸Šä¼ å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'), 'error');
                    }
                } catch (err) {
                    showToast('ç½‘ç»œé”™è¯¯', 'error');
                }

                pendingFiles = [];
                saveBtn.disabled = false;
                saveBtn.textContent = 'ä¿å­˜å¹¶åˆ·æ–°';
            });
        }

        // æ¸²æŸ“å›¾ç‰‡ç½‘æ ¼
        function renderPhotoGrid() {
            const photoGrid = document.getElementById('photo-grid');
            const allItems = [];

            // å·²æœ‰çš„ç…§ç‰‡
            currentPhotos.forEach((url, index) => {
                allItems.push(`
                    <div class="photo-item">
                        <img src="${url}" alt="ç…§ç‰‡">
                        <button class="photo-item-delete" onclick="deletePhoto('${url}', ${index})">Ã—</button>
                    </div>
                `);
            });

            // å¾…ä¸Šä¼ çš„æ–‡ä»¶é¢„è§ˆ
            pendingFiles.forEach((file, index) => {
                const previewUrl = URL.createObjectURL(file);
                allItems.push(`
                    <div class="photo-item" style="border-color: rgba(255, 215, 0, 0.5);">
                        <img src="${previewUrl}" alt="å¾…ä¸Šä¼ ">
                        <button class="photo-item-delete" onclick="removePendingFile(${index})">Ã—</button>
                    </div>
                `);
            });

            if (allItems.length === 0) {
                photoGrid.innerHTML = '<div class="photo-empty">æš‚æ— ç…§ç‰‡ï¼Œä¸Šä¼ ä¸€äº›å§~</div>';
            } else {
                photoGrid.innerHTML = allItems.join('');
            }
        }

        // åˆ é™¤å·²æœ‰ç…§ç‰‡
        window.deletePhoto = async (url, index) => {
            if (!confirm('ç¡®å®šåˆ é™¤è¿™å¼ ç…§ç‰‡å—ï¼Ÿ')) return;
            
            try {
                const resp = await fetch('/api/photos/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ photoUrl: url })
                });
                const data = await resp.json();
                if (data.ok) {
                    currentPhotos = data.photos;
                    renderPhotoGrid();
                    reloadPhotos();
                    showToast('åˆ é™¤æˆåŠŸ', 'success', 2000);
                } else {
                    showToast('åˆ é™¤å¤±è´¥', 'error');
                }
            } catch (err) {
                showToast('ç½‘ç»œé”™è¯¯', 'error');
            }
        };

        // ç§»é™¤å¾…ä¸Šä¼ çš„æ–‡ä»¶
        window.removePendingFile = (index) => {
            pendingFiles.splice(index, 1);
            renderPhotoGrid();
        };

        // --- MEDIAPIPE ---
        // Toast é€šçŸ¥å‡½æ•°
        function showToast(message, type = 'info', duration = 3000) {
            if (!message || message.trim() === '') return;

            const container = document.getElementById('toast-container');
            if (!container) return;

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            const iconMap = {
                success: 'âœ…',
                error: 'âŒ',
                info: 'â„¹ï¸',
                warning: 'âš ï¸'
            };

            toast.innerHTML = `
                <div class="toast-icon">${iconMap[type] || 'â„¹ï¸'}</div>
                <div class="toast-text">${message}</div>
            `;

            container.appendChild(toast);

            setTimeout(() => toast.classList.add('show'), 10);

            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode === container) {
                        container.removeChild(toast);
                    }
                }, 400);
            }, duration);
        }

        // åŠ è½½æç¤ºå‡½æ•°
        function showLoadingToast(message) {
            const toast = document.getElementById('loading-toast');
            const toastText = toast.querySelector('.toast-text');
            toastText.textContent = message;
            toast.classList.add('show');
        }

        function hideLoadingToast() {
            const toast = document.getElementById('loading-toast');
            toast.classList.remove('show');
        }

        async function initMediaPipe() {
            if (isCameraRunning) return;

            console.log('initMediaPipe called');
            showToast('æ­£åœ¨åˆå§‹åŒ–æ‘„åƒå¤´...', 'info', 2000);

            // æ˜¾ç¤ºåŠ è½½æç¤º
            showLoadingToast('Loading AI Vision...');

            video = document.getElementById('webcam');
            try {
                console.log('Loading FilesetResolver...');
                // åŠ è½½ Vision ä»»åŠ¡
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                console.log('FilesetResolver loaded');

                // æ›´æ–°æç¤º
                showLoadingToast('Loading Hand Model...');
                console.log('Loading HandLandmarker...');

                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                console.log('HandLandmarker loaded');

                // æ›´æ–°æç¤º
                showLoadingToast('Initializing Camera...');
                console.log('Requesting camera...');

                const constraints = { video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                console.log('Camera stream obtained');
                video.srcObject = stream;

                const startPredict = () => {
                    const playPromise = video.play && video.play();
                    if (playPromise && typeof playPromise.catch === 'function') {
                        playPromise.catch(() => {});
                    }
                    predictWebcam();
                };

                if (video.readyState >= 2) {
                    startPredict();
                } else {
                    video.onloadeddata = startPredict;
                }
                document.getElementById('webcam-wrapper').style.opacity = 1;

                // åŠ è½½å®Œæˆï¼Œå»¶è¿Ÿéšè—æç¤º
                showLoadingToast('Ready! âœ¨');
                setTimeout(() => {
                    hideLoadingToast();
                }, 1500);

                showToast('æ‰‹åŠ¿è¯†åˆ«å·²å¯åŠ¨ï¼', 'success', 2000);
                isCameraRunning = true;
                console.log('Camera initialized successfully');
            } catch(e) {
                console.error("Camera error:", e);
                hideLoadingToast();
                let msg = "æ‘„åƒå¤´é”™è¯¯: " + (e.message || e.name);
                if (e.name === 'NotAllowedError' || e.name === 'PermissionDeniedError') {
                    msg = "è¯·å…è®¸æ‘„åƒå¤´è®¿é—®æƒé™ï¼";
                } else if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
                    msg = "æ‘„åƒå¤´éœ€è¦ HTTPS åè®®ï¼";
                } else if (e.name === 'NotFoundError') {
                    msg = "æœªæ‰¾åˆ°æ‘„åƒå¤´è®¾å¤‡ï¼";
                }
                showToast(msg, 'error', 5000);
            }
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                if (handLandmarker) {
                    const result = handLandmarker.detectForVideo(video, performance.now());
                    processGestures(result);
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function processGestures(result) {
            if (result.landmarks && result.landmarks.length > 0) {
                STATE.hand.detected = true;
                const lm = result.landmarks[0];
                STATE.hand.x = (lm[9].x - 0.5) * 2; 
                STATE.hand.y = (lm[9].y - 0.5) * 2;
                const wrist = lm[0]; const middleMCP = lm[9]; 
                const handSize = Math.hypot(middleMCP.x - wrist.x, middleMCP.y - wrist.y);
                if (handSize < 0.02) return;
                const tips = [lm[8], lm[12], lm[16], lm[20]];
                let avgTipDist = 0; tips.forEach(t => avgTipDist += Math.hypot(t.x - wrist.x, t.y - wrist.y)); avgTipDist /= 4;
                const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                const extensionRatio = avgTipDist / handSize; const pinchRatio = pinchDist / handSize;
                
                debugInfo.innerText = `Gesture Detected: ${STATE.mode}`;

                if (extensionRatio < 1.5) { STATE.mode = 'TREE'; STATE.focusTarget = null; }
                else if (pinchRatio < 0.35) {
                    if (STATE.mode !== 'FOCUS') {
                        STATE.mode = 'FOCUS';
                        const photos = particleSystem.filter(p => p.type === 'PHOTO');
                        if (photos.length) STATE.focusTarget = photos[Math.floor(Math.random()*photos.length)].mesh;
                    }
                } else if (extensionRatio > 1.7) { STATE.mode = 'SCATTER'; STATE.focusTarget = null; }
            } else {
                STATE.hand.detected = false;
            }
        }
        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });

            // å¸®åŠ©æŒ‰é’®å’Œå¼¹çª—æ§åˆ¶
            const helpBtn = document.getElementById('help-btn');
            const helpModal = document.getElementById('help-modal');
            const helpClose = document.querySelector('.help-close');

            helpBtn.addEventListener('click', () => {
                helpModal.classList.add('show');
            });

            helpClose.addEventListener('click', () => {
                helpModal.classList.remove('show');
            });

            // ç‚¹å‡»èƒŒæ™¯å…³é—­å¼¹çª—
            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) {
                    helpModal.classList.remove('show');
                }
            });

            window.addEventListener('keydown', (e) => {
                // ESC å…³é—­å¸®åŠ©å¼¹çª—
                if (e.key === 'Escape' && helpModal.classList.contains('show')) {
                    helpModal.classList.remove('show');
                }

                // H é”®éšè—UI
                if (e.key.toLowerCase() === 'h') {
                    toggleUIVisibility();
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            // äº¤äº’é€»è¾‘æ ¸å¿ƒï¼šæ‰‹åŠ¿ä¼˜å…ˆ > è§¦æ‘¸ > è‡ªåŠ¨æ—‹è½¬
            if (STATE.hand.detected) {
                // æ‰‹åŠ¿æ§åˆ¶
                if (STATE.mode === 'SCATTER') {
                    const targetRotY = STATE.hand.x * Math.PI * 0.9; 
                    const targetRotX = STATE.hand.y * Math.PI * 0.25;
                    STATE.rotation.y += (targetRotY - STATE.rotation.y) * 3.0 * dt;
                    STATE.rotation.x += (targetRotX - STATE.rotation.x) * 3.0 * dt;
                } else {
                    STATE.rotation.y += 0.3 * dt;
                }
            } else if (STATE.touch.active) {
                // è§¦æ‘¸/é¼ æ ‡æ‹–åŠ¨æ§åˆ¶
            } else {
                // è‡ªåŠ¨é—²ç½®åŠ¨ç”»
                if(STATE.mode === 'TREE') {
                    STATE.rotation.y += 0.3 * dt;
                    STATE.rotation.x += (0 - STATE.rotation.x) * 2.0 * dt;
                } else {
                    STATE.rotation.y += 0.1 * dt; 
                }
            }
            mainGroup.rotation.y = STATE.rotation.y;
            mainGroup.rotation.x = STATE.rotation.x;

            particleSystem.forEach(p => p.update(dt, STATE.mode, STATE.focusTarget));
            
            // æ›´æ–°ç‚«é…·ç²’å­æ•ˆæœ
            const time = clock.elapsedTime;
            updateMagicParticles(time);
            updateSparkles(time);
            updateRingParticles(time);
            
            composer.render();
        }
        init();
    </script>
</body>

</html>
